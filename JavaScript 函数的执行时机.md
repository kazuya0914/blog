# 函数的执行时机

下面的 for 循环代码打印出的结果是 6 个`6`，而不是直觉上的`0`、`1`、`2`、`3`、`4`、`5`。我试图通过这个例子的发散来了解函数的**执行时机**

```js
let i = 0
for (i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

## 关于setTimeout

`setTimeout()`方法设置一个定时器，该定时器在定时器到期后执行一个函数或指定的一段代码。它能接受 4 个参数，分别是：

- `function`你想要在到期时间(`delay`毫秒)之后执行的函数。
- `code`这是一个可选语法，你可以使用字符串而不是function ，在delay毫秒之后编译和执行字符串。
- `delay 可选`  
  延迟的毫秒数 (一秒等于1000毫秒)，函数的调用会在该延迟之后发生。如果省略该参数，delay取默认值0，意味着“马上”执行，或者尽快执行。不管是哪种情况，实际的延迟时间可能会比期待的(delay毫秒数) 值长。
- `arg1, ..., argN 可选`附加参数，一旦定时器到期，它们会作为参数传递给`function`。

## 回头再看 6 个`6`

```js
let i = 0
for (i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

由于引入了`setTimeout`计时器，同时传入了`delay`参数`0`，所以计时器会将`console.log(i)`移出当前代码执行队列，当 for 循环体结束，再马上执行。当 for 循环结束时，`i`
的值已经为6，同时之前每次循环都使用了计时器，所以一共有 6 次`console.log(i)`会在此时执行，所以打印出了6个`6`。

## 如何在`setTimeout`中输出`0`、`1`、`2`、`3`、`4`、`5`

```js
for (let i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

上述代码，将`let`放到了 for 循环体中来声明变量`i`，JS为了让结果更符合新人的直觉，在每次执行循环体之前，JS 引擎会把`i`在循环体的上下文中重新声明及初始化一次。这样内存中就存有6个`i`的值。

那么如何将每次循环后变量`i`的值始终保存在内存中，除了使用了`let`，尝试使用了其他方法：

- **立即执行函数**

```js
let i = 0
for (i = 0; i < 6; i++) {
  !function (n) {
    setTimeout(() => {
      console.log(n)
    }, 0)
  }(i)
}
```

当函数变成立即执行的函数表达式时，表达式中的变量不能从外部访问。也可以理解为立即执行函数调用了自身作用域外的变量，形成了闭包，所以`n`的值得以保存在内存中。

- **递归**

```js
function fn(i) {
  if (i < 6) {
    setTimeout(() => {
      console.log(i);
      fn(++i)
    }, 0)
  }
}
```

即`fn(0)`调用`f(1)`，`f(1)`调用`f(2)`，直到`f(5)`调用`f(6)`，形成了互相嵌套的函数，也是一种闭包。